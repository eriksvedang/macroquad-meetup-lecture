* Create project
$ cargo new <name>

* Edit Cargo.toml
#+begin_src
[dependencies]
macroquad = "0.4"
#+end_src

* Run it
$ cargo run

* A minimal application (edit main.rs)
#+begin_src
use macroquad::prelude::*;

#[macroquad::main("Lecture")]
async fn main() {
    loop {
        clear_background(WHITE);
        next_frame().await;
    }
}
#+end_src

* Why `async`?
Makes an infinite loop like the one above work on all platforms, e.g. WASM.
`next_frame()` gives the executing thread a chance to do other things.

* Let's add a player (also known as a movable circle)
#+begin_src
    struct Player {
        position: Vec2,
        hp: u32,
    }
#+end_src

In the beginning of the main function:
#+begin_src
    let player = Player {
        position: vec2(screen_width() * 0.5, screen_height() * 0.5),
        hp: 100,
    };
#+end_src

And in the loop:
#+begin_src
    draw_circle(
        player.position.x,
        player.position.y,
        player.hp as f32 * 0.2,
        BLACK,
    );
#+end_src

* Now we want to move the player, let's get inputs
#+begin_src
fn get_input() -> Vec2 {
    let mut x = 0.0;
    let mut y = 0.0;

    if is_key_down(KeyCode::A) {
        x -= 1.0;
    }

    if is_key_down(KeyCode::D) {
        x += 1.0;
    }

    if is_key_down(KeyCode::W) {
        y -= 1.0;
    }

    if is_key_down(KeyCode::S) {
        y += 1.0;
    }

    vec2(x, y)
}
#+end_src

And in the beginning of the loop:
#+begin_src
  player.position += get_input();
#+end_src

Need to make `player` mutable!

To get the same speed when moving diagonally:
#+begin_src
  vec2(x, y).clamp_length(0.0, 1.0)
#+end_src

* Let's add `speed` to the Player struct
#+begin_src
struct Player {
    position: Vec2,
    speed: f32,
    hp: u32,
}
#+end_src

#+begin_src
  let mut player = Player {
    ...
    speed: 150.0,
  };
#+end_src

#+begin_src
  player.position += get_input() * player.speed * get_frame_time();
#+end_src

* Let's create a function that handles drawing the player!
Requires "borrowing", probably the most famous feature of Rust:
#+begin_src
pub fn draw(player: &Player) {
    draw_circle(
        player.position.x,
        player.position.y,
        player.hp as f32 * 0.2,
        BLACK,
    );
}
#+end_src

* Lets do that with the input handling too
That requires a mutable borrow:
#+begin_src
pub fn update(player: &mut Player) {
    player.position += get_input() * player.speed * get_frame_time();
}
#+end_src

* Maybe we want to organize our code even better?
Let's do two things:
- Move the Player struct to its own module.
- Associate the rendering and updating of the player more clearly with the Player struct.

* The new player.rs
#+begin_src
use macroquad::prelude::*;

pub struct Player {
    pub position: Vec2,
    pub speed: f32,
    pub hp: u32,
}

impl Player {
    pub fn draw(&self) {
        draw_circle(
            self.position.x,
            self.position.y,
            self.hp as f32 * 0.2,
            BLACK,
        );
    }

    pub fn update(&mut self, input: Vec2, dt: f32) {
        self.position += input * self.speed;
    }
}
#+end_src

* Need to add some things in main.rs
Add the module as a child module of the top crate of the project:
#+begin_src
  mod player;
#+end_src

And qualify the struct name:

#+begin_src
  player::Player
#+end_src

Which lets us write the loop like so:

#+begin_src
    loop {
        clear_background(WHITE);
        player.update(get_input(), get_frame_time());
        player.draw();
        next_frame().await;
    }
#+end_src
* Perhaps we want to shoot bullets? Let's add a struct for that
#+begin_src
use macroquad::prelude::*;

pub struct Bullet {
    pub pos: Vec2,
    pub dir: f32,
    pub speed: f32,
}
#+end_src

* Add the module to main.rs and use it

#+begin_src
  mod bullet;
  use bullet::Bullet;
#+end_src

* Create a Vec to hold the bullets
#+begin_src

let mut bullets: Vec<Bullet> = Vec::new();
#+end_src

* Then check for mouse clicks, update and draw the bullets in the main loop
#+begin_src
        if is_mouse_button_pressed(MouseButton::Left) {
            bullets.push(Bullet {
                pos: player.position,
                dir: 0.0,
                speed: 100.0,
            })
        }

        for bullet in &mut bullets {
            bullet.pos += Vec2::from_angle(bullet.dir) * get_frame_time() * bullet.speed;
            draw_circle(bullet.pos.x, bullet.pos.y, 10.0, RED);
        }
#+end_src

* Want to remove bullets if they are outside the screen
#+begin_src
  bullets.retain(|bullet| bullet.pos.x < screen_width() - 50.0);
#+end_src
